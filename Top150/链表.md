- [环形链表](#环形链表)
- [两数相加](#两数相加)
- [合并两个有序链表](#合并两个有序链表)
- [随机链表的复制](#随机链表的复制)
- [反转链表 II](#反转链表-ii)
- [K 个一组翻转链表](#k-个一组翻转链表)
- [删除链表的倒数第 N 个结点](#删除链表的倒数第-n-个结点)
- [删除排序链表中的重复元素 II](#删除排序链表中的重复元素-ii)
- [旋转链表](#旋转链表)
- [分隔链表](#分隔链表)
- [LRU 缓存](#lru-缓存)
### 环形链表
``` cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if(head==nullptr) return false;
        ListNode* p=head,*cur=head;
        do 
        {
            p=p->next;
            cur=cur->next;
            if(cur) cur=cur->next;
        }while(cur&&p!=cur);
        if(cur==nullptr) return false;
        return true;
    }
};
```
### 两数相加
``` cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode * head=new ListNode;
        ListNode* p=head;
        int t=0;
        while(l1&&l2)
        {
            int sum=l1->val+l2->val+t;
            p->next=new ListNode(sum%10);
            t=sum/10;
            p=p->next;
            l1=l1->next;
            l2=l2->next;
        }
        while(l1)
        {
            int sum=l1->val+t;
            p->next=new ListNode(sum%10);
            t=sum/10;
            p=p->next;
            l1=l1->next;
        }
        while(l2)
        {
            int sum=l2->val+t;
            p->next=new ListNode(sum%10);
            t=sum/10;
            p=p->next;
            l2=l2->next;
        }
        if(t)
        {
            p->next=new ListNode(t);
            p=p->next;
        }
        p->next=nullptr;
        p=head->next;
        delete head;
        return p;
    }
};
```
### 合并两个有序链表
``` cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode* head=new ListNode;
        ListNode* p=head;
        while(list1&&list2)
        {
            if(list1->val<list2->val)
            {
                p->next=list1;
                list1=list1->next;
            }
            else
            {
                p->next=list2;
                list2=list2->next;
            }
            p=p->next;
        }
        while(list1)
        {
            p->next=list1;
            list1=list1->next;
            p=p->next;
        }
        while(list2)
        {
            p->next=list2;
            list2=list2->next;
            p=p->next;
        }
        p->next=nullptr;
        p=head->next;
        delete head;
        return p;
    }
};
```
### 随机链表的复制
``` cpp
"""
# Definition for a Node.
class Node:
    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):
        self.val = int(x)
        self.next = next
        self.random = random
"""

class Solution:
    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':
        if head is None :
            return None
        h=head
        while head is not None:
            next=head.next 
            head.next=Node(head.val)
            head.next.next=next
            head=next
        head=h
        while head is not None:
            if head.random is not None:
                head.next.random=head.random.next 
            head=head.next.next 
        ret=Node(0)
        p=ret
        head=h
        while head is not None:
            p.next=head.next 
            head.next=head.next.next 
            head=head.next
            p=p.next
        return ret.next
```
### 反转链表 II
### K 个一组翻转链表
### 删除链表的倒数第 N 个结点
### 删除排序链表中的重复元素 II
### 旋转链表
### 分隔链表
### LRU 缓存