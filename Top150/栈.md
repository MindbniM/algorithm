- [有效的括号](#有效的括号)
- [简化路径](#简化路径)
- [最小栈](#最小栈)
- [逆波兰表达式求值](#逆波兰表达式求值)
- [基本计算器](#基本计算器)

### 有效的括号
``` cpp
class Solution {
public:
#define XXX(st,c1,c2)   if(ch==c1) st.push(ch); else if(ch==c2){if(st.empty()||st.top()!=c1) return false; st.pop(); }
    bool isValid(string s) {
        stack<char> st;
        for(auto& ch:s)
        {
            XXX(st,'(',')')
            XXX(st,'[',']')
            XXX(st,'{','}')
        }
        return st.empty();
    }
};
```
### 简化路径
``` cpp
class Solution {
public:
    string simplifyPath(string path) {
        string re="/";
        stack<string> st;
        size_t i=0;
        int n=path.size();
        while(i<n)
        {
            if(path[i]!='/')
            {
                size_t n=path.find('/',i);
                string temp=path.substr(i,n-i);
                //cout<<temp<<endl;
                if(temp=="..")
                {
                    if(!st.empty()) st.pop();
                }
                else if(temp!=".")st.push(temp);
                i=n;
            }
            else i++;
        }
        stack<string> temp;
        while(!st.empty())
        {
            temp.push(st.top());
            st.pop();
        }
        while(!temp.empty())
        {
            re+=temp.top();
            re+='/';
            temp.pop();
        }
        if(re.back()=='/'&&re.size()>1) re.pop_back();
        return re;
    }
};
```
### 最小栈
``` cpp
class MinStack {
public:
    stack<int> st;
    stack<int> m;
    MinStack() {
    }
    
    void push(int val) {
        st.push(val);
        if(m.empty()||val<=m.top()) m.push(val);
    }
    
    void pop() {
        int val=st.top();
        st.pop();
        if(val==m.top()) m.pop();
    }
    
    int top() {
        return st.top();
    }
    
    int getMin() {
        return m.top();
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(val);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->getMin();
 */
```
### 逆波兰表达式求值
### 基本计算器