- [二叉树的最大深度](#二叉树的最大深度)
- [相同的树](#相同的树)
- [翻转二叉树](#翻转二叉树)
- [对称二叉树](#对称二叉树)
- [从前序与中序遍历序列构造二叉树](#从前序与中序遍历序列构造二叉树)
- [从中序与后序遍历序列构造二叉树](#从中序与后序遍历序列构造二叉树)
- [填充每个节点的下一个右侧节点指针 II](#填充每个节点的下一个右侧节点指针-ii)
- [二叉树展开为链表](#二叉树展开为链表)
- [路径总和](#路径总和)
- [求根节点到叶节点数字之和](#求根节点到叶节点数字之和)
- [二叉树中的最大路径和](#二叉树中的最大路径和)
- [二叉搜索树迭代器](#二叉搜索树迭代器)
- [完全二叉树的节点个数](#完全二叉树的节点个数)
- [二叉树的最近公共祖先](#二叉树的最近公共祖先)
### 二叉树的最大深度
``` cpp
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root==nullptr) return 0;
        return max(maxDepth(root->left),maxDepth(root->right))+1;
    }
};
```
### 相同的树
``` cpp
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if((p&&!q)||(!p&&q)) return false;
        if(!p&&!q) return true;
        bool flag=p->val==q->val;
        return flag&&isSameTree(p->left,q->left)&&isSameTree(p->right,q->right);
    }
};
```
### 翻转二叉树
``` cpp
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(root==nullptr) return root;
        swap(root->left,root->right);
        invertTree(root->left);
        invertTree(root->right);
        return root;
    }
};
```
### 对称二叉树
### 从前序与中序遍历序列构造二叉树
### 从中序与后序遍历序列构造二叉树
### 填充每个节点的下一个右侧节点指针 II
### 二叉树展开为链表
### 路径总和
### 求根节点到叶节点数字之和
### 二叉树中的最大路径和
### 二叉搜索树迭代器
### 完全二叉树的节点个数
### 二叉树的最近公共祖先