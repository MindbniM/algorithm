- [二叉树的最大深度](#二叉树的最大深度)
- [相同的树](#相同的树)
- [翻转二叉树](#翻转二叉树)
- [对称二叉树](#对称二叉树)
- [从前序与中序遍历序列构造二叉树](#从前序与中序遍历序列构造二叉树)
- [从中序与后序遍历序列构造二叉树](#从中序与后序遍历序列构造二叉树)
- [填充每个节点的下一个右侧节点指针 II](#填充每个节点的下一个右侧节点指针-ii)
- [二叉树展开为链表](#二叉树展开为链表)
- [路径总和](#路径总和)
- [求根节点到叶节点数字之和](#求根节点到叶节点数字之和)
- [二叉树中的最大路径和](#二叉树中的最大路径和)
- [二叉搜索树迭代器](#二叉搜索树迭代器)
- [完全二叉树的节点个数](#完全二叉树的节点个数)
- [二叉树的最近公共祖先](#二叉树的最近公共祖先)
### 二叉树的最大深度
``` cpp
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root==nullptr) return 0;
        return max(maxDepth(root->left),maxDepth(root->right))+1;
    }
};
```
### 相同的树
``` cpp
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if((p&&!q)||(!p&&q)) return false;
        if(!p&&!q) return true;
        bool flag=p->val==q->val;
        return flag&&isSameTree(p->left,q->left)&&isSameTree(p->right,q->right);
    }
};
```
### 翻转二叉树
``` cpp
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(root==nullptr) return root;
        swap(root->left,root->right);
        invertTree(root->left);
        invertTree(root->right);
        return root;
    }
};
```
### 对称二叉树
``` cpp
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def dfs(self,left:Optional[TreeNode],right : Optional[TreeNode]) -> bool:
        if left is None and right is None:
            return True
        if left and right is  None:
            return False
        if left is  None and right:
            return False
        if left.val != right.val:
            return False
        l=self.dfs(left.left,right.right)
        r=self.dfs(left.right,right.left)
        return l and r
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        if root is None:
            return True
        return self.dfs(root.left,root.right)
        /**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool _is(TreeNode* r1,TreeNode* r2)
    {
        if(!r1&&!r2) return true;
        if((!r1&&r2)||(r1&&!r2)) return false;
        if(r1->val!=r2->val) return false;
        bool left=_is(r1->left,r2->right);
        bool right=_is(r1->right,r2->left);
        return left&&right;
    }
    bool isSymmetric(TreeNode* root) {
        if(root==nullptr) return true;
        return _is(root->left,root->right);
    }
};
```
### 从前序与中序遍历序列构造二叉树
### 从中序与后序遍历序列构造二叉树
### 填充每个节点的下一个右侧节点指针 II
### 二叉树展开为链表
### 路径总和
### 求根节点到叶节点数字之和
### 二叉树中的最大路径和
### 二叉搜索树迭代器
### 完全二叉树的节点个数
### 二叉树的最近公共祖先